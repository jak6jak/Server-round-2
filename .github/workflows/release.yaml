name: 'ðŸ“¦ Release'
on:
  # Manual trigger.
  workflow_dispatch:
    inputs:
      bump:
        type: string
        description: "major, minor, or patch"
        required: true
        default: "patch"
  # Reusable workflow trigger.
  workflow_call:
    inputs:
      bump:
        type: string
        description: "major, minor, or patch"
        required: true
        default: "patch"

# Prevent overlapping releases on the same ref.
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write      # create release & read tags
  packages: write      # (future) if publishing to GHCR
  actions: read
  id-token: write      # (future) OIDC usage if moving off API keys

jobs:
  release:
    name: 'ðŸ“¦ Release'
    runs-on: ubuntu-latest
    env:
      DOTNET_CLI_TELEMETRY_OPTOUT: true
      DOTNET_NOLOGO: true
    steps:
      - name: ðŸ§¾ Checkout
        uses: actions/checkout@v4
        with:
          lfs: true
          submodules: 'recursive'
          fetch-depth: 0 # So we can get all tags.

      - name: ðŸ”Ž Read Current Project Version
        id: current-version
        uses: WyriHaximus/github-action-get-previous-tag@v1
        with:
          fallback: "0.0.0-devbuild"

      - name: ðŸ–¨ Print Current Version
        run: |
          echo "Current Version: ${{ steps.current-version.outputs.tag }}"

      - name: ðŸ§® Compute Next Version
        uses: chickensoft-games/next-godot-csproj-version@v1
        id: next-version
        with:
          project-version: ${{ steps.current-version.outputs.tag }}
          godot-version: global.json
          bump: ${{ inputs.bump }}
      - uses: actions/setup-dotnet@v4
        name: ðŸ’½ Setup .NET SDK
        with:
          global-json-file: global.json
          cache: true

      - name: ðŸ“¦ Restore
        run: dotnet restore Server2/Server2.csproj

      - name: ðŸ›  Build (Version Override)
        run: |
          set -euo pipefail
          dotnet build Server2/Server2.csproj -c Release -p:Version=${{ steps.next-version.outputs.version }}

      # Build & push Docker image to GHCR.
      - name: ðŸ§° Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ðŸ” Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ· Prepare Image Tags
        id: image
        run: |
          VERSION=${{ steps.next-version.outputs.version }}
          REPO_IMAGE=ghcr.io/${{ github.repository_owner }}/server2
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "repo_image=$REPO_IMAGE" >> $GITHUB_OUTPUT
          echo "tags=$REPO_IMAGE:$VERSION,$REPO_IMAGE:latest" >> $GITHUB_OUTPUT

      - name: ï¿½ Build & Push Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: true
          build-args: |
            VERSION=${{ steps.next-version.outputs.version }}
          tags: ${{ steps.image.outputs.tags }}
          provenance: false

      - name: âœ¨ Create Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          version="${{ steps.next-version.outputs.version }}"
          notes="Docker image: ghcr.io/${{ github.repository_owner }}/server2:$version"
          gh release create "$version" --title "v$version" --notes "$notes" --generate-notes
